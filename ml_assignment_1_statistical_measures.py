# -*- coding: utf-8 -*-
"""ML-Assignment_1-Statistical_Measures.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ggr1I1XecabfNBHhqs0K6Gy38cb0gTn_

##**Importing Libraries and loading Dataset**
"""

import numpy as np
import pandas as pd

org_df = pd.read_csv('/content/house_price.csv')

#taking copy of org_df for operations and keeping org_df as backup
df = org_df.copy()

"""###Q1. Perform basic EDA"""

#first 5 rows of dataframe
df.head()

#shape of dataframe
df.shape

#columns of dataframe
df.columns

#informations about the dataset
df.info()

#checking null values
df.isnull().sum()

#examine price_per_sqft column to check min, max, mean and percentile values
df.price_per_sqft.describe()

#examine columns to check min, max, meand and percentile values
df.describe().T

#Check unique values in bath and size columns
df['size'].unique()

df['bath'].unique()

"""##**Analsis after EDA**

##Findings other than price_per_sqft

##1. bath column which represent bathroom has upto 40 which is not possible to happen.
##2. size column which represent size or number of bedroom has upto 43 which is not possible to happen, and also the column has both integer and string values which is not in a standard form. String values are different too.

###Q2. Detect the outliers using following methods and remove it using methods like trimming / capping/ imputation using mean or median
"""

#a) Mean and Standard deviation

#limits
max_limit = df.price_per_sqft.mean() + 3 * df.price_per_sqft.std()
min_limit = df.price_per_sqft.mean() - 3 * df.price_per_sqft.std()

#outliers
outliers_mean_std = df.loc[(df['price_per_sqft'] > max_limit) | (df['price_per_sqft'] < min_limit)]

#1) trimming
trim_mean_std_df = df.loc[(df['price_per_sqft'] <= max_limit) & (df['price_per_sqft'] >= min_limit)]

#2) capping
cap_df_mean_std = df.copy()
cap_df_mean_std['price_per_sqft'] = cap_df_mean_std['price_per_sqft'].astype(float)
cap_df_mean_std.loc[cap_df_mean_std['price_per_sqft'] > max_limit, 'price_per_sqft'] = max_limit
cap_df_mean_std.loc[cap_df_mean_std['price_per_sqft'] < min_limit, 'price_per_sqft'] = min_limit

#3) imputation using median
imp_median_std_df = df.copy()
imp_median_std_df['price_per_sqft'] = imp_median_std_df['price_per_sqft'].astype(float)
median = imp_median_std_df['price_per_sqft'].median()
imp_median_std_df.loc[imp_median_std_df['price_per_sqft'] > max_limit, 'price_per_sqft'] = median
imp_median_std_df.loc[imp_median_std_df['price_per_sqft'] < min_limit, 'price_per_sqft'] = median

#b) Percentile method

#limits
upper_limit = np.percentile(df['price_per_sqft'], 95)
lower_limit = np.percentile(df['price_per_sqft'], 5)

#outliers
outliers_percentile = df.loc[(df['price_per_sqft'] < lower_limit) | (df['price_per_sqft'] > upper_limit)]

#1) trimming
trim_percentile_df = df.loc[(df['price_per_sqft'] >= lower_limit) & (df['price_per_sqft'] <= upper_limit)]

#2) capping
cap_percentile_df = df.copy()
cap_percentile_df['price_per_sqft'] = cap_percentile_df['price_per_sqft'].astype(float)
cap_percentile_df.loc[cap_percentile_df['price_per_sqft'] > upper_limit, 'price_per_sqft'] = upper_limit
cap_percentile_df.loc[cap_percentile_df['price_per_sqft'] < lower_limit, 'price_per_sqft'] = lower_limit

#3) imputation using median
imp_median_percentile_df = df.copy()
imp_median_percentile_df['price_per_sqft'] = imp_median_percentile_df['price_per_sqft'].astype(float)
median = imp_median_percentile_df['price_per_sqft'].median()
imp_median_percentile_df.loc[imp_median_percentile_df['price_per_sqft'] > upper_limit, 'price_per_sqft'] = median
imp_median_percentile_df.loc[imp_median_percentile_df['price_per_sqft'] < lower_limit, 'price_per_sqft'] = median

#c) IQR(Inter quartile range method)

#limits
Q1 = df['price_per_sqft'].quantile(0.25)
Q3 = df['price_per_sqft'].quantile(0.75)

IQR = Q3 - Q1

upper_limit = Q3 + 1.5 * IQR
lower_limit = Q1 - 1.5 * IQR

#1) trimming
trim_iqr_df = df.loc[(df['price_per_sqft'] >= lower_limit) & (df['price_per_sqft'] <= upper_limit)]

#2) capping
cap_iqr_df = df.copy()
cap_iqr_df['price_per_sqft'] = cap_iqr_df['price_per_sqft'].astype(float)
cap_iqr_df.loc[cap_iqr_df['price_per_sqft'] > upper_limit, 'price_per_sqft'] = upper_limit
cap_iqr_df.loc[cap_iqr_df['price_per_sqft'] < lower_limit, 'price_per_sqft'] = lower_limit

#3) imputation using median
imp_median_iqr_df = df.copy()
imp_median_iqr_df['price_per_sqft'] = imp_median_iqr_df['price_per_sqft'].astype(float)
median = imp_median_iqr_df['price_per_sqft'].median()
imp_median_iqr_df.loc[imp_median_iqr_df['price_per_sqft'] > upper_limit, 'price_per_sqft'] = median
imp_median_iqr_df.loc[imp_median_iqr_df['price_per_sqft'] < lower_limit, 'price_per_sqft'] = median

#d) Z-score method

from scipy.stats import zscore

#compute z-scores
df['z_score'] = zscore(df['price_per_sqft'])

#limits
z_upper_limit = 3
z_lower_limit = -3

#outliers
outliers_z_score = df.loc[(df['z_score'] > z_upper_limit) | (df['z_score'] < z_lower_limit)]

#1) trimming
trim_df_z_score = df.loc[(df['z_score'] <= z_upper_limit) & (df['z_score'] >= z_lower_limit)]

#2) capping
cap_df_z_score = df.copy()
cap_df_z_score['price_per_sqft'] = cap_df_z_score['price_per_sqft'].astype(float)
cap_df_z_score.loc[cap_df_z_score['z_score'] > z_upper_limit, 'price_per_sqft'] = (df['price_per_sqft'].mean() + z_upper_limit * df['price_per_sqft'].std())
cap_df_z_score.loc[cap_df_z_score['z_score'] < z_lower_limit, 'price_per_sqft'] = (df['price_per_sqft'].mean() - z_lower_limit * df['price_per_sqft'].std())

#3) imputation using median
imp_median_df_z_score = df.copy()
imp_median_df_z_score['price_per_sqft'] = imp_median_df_z_score['price_per_sqft'].astype(float)
median_z_score = imp_median_df_z_score['price_per_sqft'].median()
imp_median_df_z_score.loc[imp_median_df_z_score['z_score'] > z_upper_limit, 'price_per_sqft'] = median_z_score
imp_median_df_z_score.loc[imp_median_df_z_score['z_score'] < z_lower_limit, 'price_per_sqft'] = median_z_score

"""###Q3. Create a box plot and use this to determine which method seems to work best to remove outliers for this data?"""

import matplotlib.pyplot as plt
import seaborn as sns

#compare methods

fig, axes = plt.subplots(2, 2, figsize=(15, 10))
fig.suptitle('Outliers Trimmed', fontsize=16)

sns.boxplot(data=trim_mean_std_df, x='price_per_sqft', ax=axes[0, 0]).set_title('Mean-STD Method')
sns.boxplot(data=trim_percentile_df, x='price_per_sqft', ax=axes[0, 1]).set_title('Percentile Method')
sns.boxplot(data=trim_iqr_df, x='price_per_sqft', ax=axes[1, 0]).set_title('IQR Method')
sns.boxplot(data=trim_df_z_score, x='price_per_sqft', ax=axes[1, 1]).set_title('Z-Score Method')


plt.show()

fig, axes = plt.subplots(2, 2, figsize=(15, 10))
fig.suptitle('Outliers Capped', fontsize=16)

sns.boxplot(data=cap_df_mean_std, x='price_per_sqft', ax=axes[0, 0]).set_title('Mean-STD Method')
sns.boxplot(data=cap_percentile_df, x='price_per_sqft', ax=axes[0, 1]).set_title('Percentile Method')
sns.boxplot(data=cap_iqr_df, x='price_per_sqft', ax=axes[1, 0]).set_title('IQR Method')
sns.boxplot(data=cap_df_z_score, x='price_per_sqft', ax=axes[1, 1]).set_title('Z-Score Method')


plt.show()

fig, axes = plt.subplots(2, 2, figsize=(15, 10))
fig.suptitle('Imputation using Median', fontsize=16)

sns.boxplot(data=imp_median_std_df, x='price_per_sqft', ax=axes[0, 0]).set_title('Mean-STD Method')
sns.boxplot(data=imp_median_percentile_df, x='price_per_sqft', ax=axes[0, 1]).set_title('Percentile Method')
sns.boxplot(data=imp_median_iqr_df, x='price_per_sqft', ax=axes[1, 0]).set_title('IQR Method')
sns.boxplot(data=imp_median_df_z_score, x='price_per_sqft', ax=axes[1, 1]).set_title('Z-Score Method')

plt.show()

"""#From the above comparison of methods for outlier detection IQR(Inter quartile range method) is the best method in my findings while comparing to other methods like Mean-STD, Percentile and Z-Score. For fixing the limits "Capping" is the best way in IQR(Inter quartile range method).

###Q4. Draw histplot to check the normality of the column(price per sqft column) and perform transformations if needed. Check the skewness and kurtosis before and after the transformation.

#cap_iqr_df is using for transformation because it ensures that extreme outliers are managed before applying these transformations
"""

from scipy.stats import skew, kurtosis, boxcox, yeojohnson
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

#Original histogram for price_per_sqft using cap_iqr_df
plt.figure(figsize=(8, 4))
sns.histplot(cap_iqr_df['price_per_sqft'], kde=True, bins=30, color='orange')
plt.title("Histogram of price_per_sqft (Original)")
plt.show()

#Calculate skewness and kurtosis before transformation
original_skewness = skew(cap_iqr_df['price_per_sqft'], nan_policy='omit')
original_kurtosis = kurtosis(cap_iqr_df['price_per_sqft'], nan_policy='omit')

print(f"Original Skewness: {original_skewness}")
print(f"Original Kurtosis: {original_kurtosis}")

#Apply transformations

#1) Log Transformation
cap_iqr_df['price_per_sqft_log'] = np.log1p(cap_iqr_df['price_per_sqft'])

#2) Square Root Transformation
cap_iqr_df['price_per_sqft_sqrt'] = np.sqrt(cap_iqr_df['price_per_sqft'])

#3) Cube Root Transformation
cap_iqr_df['price_per_sqft_cbrt'] = np.cbrt(cap_iqr_df['price_per_sqft'])

#4) Reciprocal Transformation
cap_iqr_df['price_per_sqft_reciprocal'] = np.reciprocal(cap_iqr_df['price_per_sqft'])

#5) Box-Cox Transformation (requires positive values)
df['price_per_sqft_boxcox'], _ = boxcox(df['price_per_sqft'] + 1e-5)

#6) Yeo-Johnson Transformation (can handle non-positive values)
df['price_per_sqft_yeojohnson'], _ = yeojohnson(df['price_per_sqft'])

#Plot histograms after transformations
plt.figure(figsize=(15, 6))

#Log Transformation
plt.subplot(2, 3, 1)
sns.histplot(cap_iqr_df['price_per_sqft_log'], kde=True, bins=30, color='blue')
plt.title("Log Transformation")

#Square Root Transformation
plt.subplot(2, 3, 2)
sns.histplot(cap_iqr_df['price_per_sqft_sqrt'], kde=True, bins=30, color='green')
plt.title("Square Root Transformation")

#Cube Root Transformation
plt.subplot(2, 3, 3)
sns.histplot(cap_iqr_df['price_per_sqft_cbrt'], kde=True, bins=30, color='purple')
plt.title("Cube Root Transformation")

#Reciprocal Transformation
plt.subplot(2, 3, 4)
sns.histplot(cap_iqr_df['price_per_sqft_reciprocal'], kde=True, bins=30, color='red')
plt.title("Reciprocal Transformation")

#Box-Cox Transformation
plt.subplot(2, 3, 5)
sns.histplot(df['price_per_sqft_boxcox'], kde=True, bins=30, color='cyan')
plt.title("Box-Cox Transformation")

#Yeo-Johnson Transformation
plt.subplot(2, 3, 6)
sns.histplot(df['price_per_sqft_yeojohnson'], kde=True, bins=30, color='orange')
plt.title("Yeo-Johnson Transformation")

plt.tight_layout()
plt.show()

#Calculate skewness and kurtosis after transformations
log_skewness = skew(cap_iqr_df['price_per_sqft_log'], nan_policy='omit')
log_kurtosis = kurtosis(cap_iqr_df['price_per_sqft_log'], nan_policy='omit')

sqrt_skewness = skew(cap_iqr_df['price_per_sqft_sqrt'], nan_policy='omit')
sqrt_kurtosis = kurtosis(cap_iqr_df['price_per_sqft_sqrt'], nan_policy='omit')

cbrt_skewness = skew(cap_iqr_df['price_per_sqft_cbrt'], nan_policy='omit')
cbrt_kurtosis = kurtosis(cap_iqr_df['price_per_sqft_cbrt'], nan_policy='omit')

reciprocal_skewness = skew(cap_iqr_df['price_per_sqft_reciprocal'], nan_policy='omit')
reciprocal_kurtosis = kurtosis(cap_iqr_df['price_per_sqft_reciprocal'], nan_policy='omit')

boxcox_skewness = skew(df['price_per_sqft_boxcox'], nan_policy='omit')
boxcox_kurtosis = kurtosis(df['price_per_sqft_boxcox'], nan_policy='omit')

yeojohnson_skewness = skew(df['price_per_sqft_yeojohnson'], nan_policy='omit')
yeojohnson_kurtosis = kurtosis(df['price_per_sqft_yeojohnson'], nan_policy='omit')


# Print skewness and kurtosis for all transformations
print(f"Log Transformation - Skewness: {log_skewness}, Kurtosis: {log_kurtosis}")
print(f"Square Root Transformation - Skewness: {sqrt_skewness}, Kurtosis: {sqrt_kurtosis}")
print(f"Cube Root Transformation - Skewness: {cbrt_skewness}, Kurtosis: {cbrt_kurtosis}")
print(f"Reciprocal Transformation - Skewness: {reciprocal_skewness}, Kurtosis : {reciprocal_kurtosis}")
print(f"Box-Cox Transformation - Skewness: {boxcox_skewness}, Kurtosis: {boxcox_kurtosis}")
print(f"Yeo-Johnson Transformation - Skewness: {yeojohnson_skewness}, Kurtosis: {yeojohnson_kurtosis}")

"""###Q5. Check the correlation between all the numerical columns and plot heatmap"""

#here using org_df for correlation

#correlation matrix
correlation_matrix = org_df.corr(numeric_only=True)

#jheatmap of correlations
plt.figure(figsize=(12, 7))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title("Correlation Heatmap")
plt.show()

"""###Q6. Draw Scatter plot between the variables to check the correlation between them."""

# Scatter plot between numerical variables
numerical_columns = ['price_per_sqft', 'size', 'bath', 'total_sqft', 'bhk', 'price']

# Plotting scatter plots
import matplotlib.pyplot as plt
import seaborn as sns

# Creating scatter plots for each pair of numerical columns
fig, axes = plt.subplots(len(numerical_columns), len(numerical_columns), figsize=(15, 15))
fig.suptitle('Scatter Plots to Check Correlation Between Variables', fontsize=16)

for i, col1 in enumerate(numerical_columns):
    for j, col2 in enumerate(numerical_columns):
        if i == j:
            # Diagonal with histograms
            sns.histplot(cap_iqr_df[col1], bins=30, ax=axes[i, j], kde=True)
            axes[i, j].set_title(f"Histogram of {col1}")
        else:
            # Off-diagonal with scatter plots
            sns.scatterplot(x=cap_iqr_df[col1], y=cap_iqr_df[col2], ax=axes[i, j])
            axes[i, j].set_title(f"{col1} vs {col2}")

plt.tight_layout()
plt.show()